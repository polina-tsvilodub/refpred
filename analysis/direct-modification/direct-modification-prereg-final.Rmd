---
title: "Direct Modification Results - Prereg Final"
author: "Polina Tsvilodub"
date: "12/13/2020"
output: github_document
---

This write-up presents results of the final direct-modification experiment for the refpred project. In this experiment we manipulate the syntactic position of the noun directly modified by the adjective (“big Great Dane” appearing in the subject or in the predicate) in order to disentangle effects of reasoning about informational goals on comparison class inference from effects of syntactic modification.

Our [Bayesian power analysis](https://github.com/polina-tsvilodub/refpred/blob/master/analysis/direct-modification/direct-modification_power_bySubj-byItem_write-up.md) based on pilot data revealed that for a power above 0.8 we need at least 300 subjects, so for this final [preregistered](https://osf.io/vt3f7) study we recruited N=330 on Prolific, aiming for N=300 passing the exclusion criteria. 

# Experiment design
The experiment has a 2x2 within-subjects design, manipulating the syntactic position of subordinate nouns (subject vs predicate N) and the trial-type (critical vs filer, where fillers are trials from our CogSci Experiment 3), all appearing in basic-level context. 

Participants see a context picture and read a sentence about a referent which they have to paraphrase, completing a total of eight main trials, presented in two blocks of four main trials each. The eight main trials consist of four critical and four filler trials, where each trial is a condition resulting from a unique combination of the noun position condition (subject N vs. predicate N) crossed with the size of the referent within its basic-level category (e.g., large vs. small subordinate dog category). Ten contexts created from six different basic-level categories are used: dogs, flowers, birds, fish, buildings and trees. For each basic-level context, there are two possible targets representing a large-subordinate and a small-subordinate category, respectively. Four contexts are sampled for each participant. Information about the items can be found [here](https://docs.google.com/document/d/1yxF9ACALa6MQB70nYydGStvLiY0JjO8mmkASI049lT4/edit?usp=sharing).

```{r setup, include=FALSE}
library(tidyverse)
library(brms)
library(tidyboot)
library(tidybayes)
```


```{r, message=F, warning=F, include=F}
data <- read_csv("../../data/direct-modification/results_prolific_final.csv")

```
# Analysis

## Data Preprocessing

We collected data from N = 323 participants. 
4 participants are excluded for not reporting their native language, or being non-native English speakers. 3 subjects failed the comparison class paraphrase warm-up trial (i.e., took more than 4 attempts to enter the right response upon correction); 14 subjects failed the labeling warm-up trials (also taking more than 4 attempts upon correction). Overall, 15 subjects were excluded for failing the warm-ups. This leaves N = 304. Last 4 received submissions are excluded for an N = 300. 

```{r clean}
# exclude participants who report glitches
data %>% select(submission_id, comments, problems) %>% distinct() %>% View()
d_modRef_woGlitches <- data 

# exclude non-native English speakers
d_modRef_woGlitches %>% distinct(languages) %>% View()

# 323 participants received
d_modRef_Native <- d_modRef_woGlitches %>% 
  filter(grepl("en", languages, ignore.case = T)) 
# excluded 4 as non-native English speakers

# cleaning warm-up trials
# comparison class paraphrase trial

# excludes 3
d_failed_cc_warmup <- d_modRef_Native %>% 
  filter( trial_name == "comp_class_warmup") %>%
  group_by(submission_id) %>% count() %>%
  filter( n > 4 )
# excludes 14
d_failed_label_warmup <- d_modRef_Native %>%
  filter( (trial_name == "warmup1") | (trial_name == "warmup2")) %>%
  group_by(submission_id) %>%
  filter(attempts > 4)
d_label_warmup_more1 <- d_modRef_Native %>%
  filter( (trial_name == "warmup1") | (trial_name == "warmup2")) %>%
  group_by(submission_id) %>%
  filter(attempts > 1) %>% ungroup() %>% 
  select(submission_id, picture1, response1, picture2, response2, attempts)

# 304 left 
d_modRef_filter <- anti_join(d_modRef_Native, d_failed_cc_warmup, by = c("submission_id"))
d_modRef_filter <- anti_join(d_modRef_filter, d_failed_label_warmup, by = c("submission_id"))

# exclude last 4 submissions to get 300 subjects
d_modRef_filter300 <- d_modRef_filter %>% filter(!(submission_id %in% c(2644, 2645, 2646, 2647)))
```

Check the balancing of conditions:
```{r count}
d_modRef_filter300 %>% count(trial_type, syntax, target_size)
```

### Response Classification

#### Minimal exclusions

First, invalid responses are excluded. This is a minimal pre-processing step:  Excluded responses consist of disjunctions/conjunctions, massive misspellings, compare the referent to a size, or to an invalid subordinate category (reference failure). This excludes 21 responses (0.9%).

``` {r invalid}
d_modRef_main <- d_modRef_filter300 %>% filter((trial_name == "custom_main_text1") |
                                (trial_name == "custom_main_text2")) %>%
  select(submission_id, trial_number, context_picture, response, target_size, adj, syntax, target, item, adj_cond, trial_type, ref_np )

d_modRef_main %>% distinct(response) %>% View()

# exclude 21 answers with minimal exclusion criteria
d_modRef_valid <- d_modRef_main %>% 
  subset(., !(tolower(response) %in% c("deandal", "compared to the other fish", "compared to the fish", "the size of the flower", "pigeon or other common birds", "a rose", "pigeon", "trees or himself", "dogs or the bow", "landmark or trees", "bow/gift", "sunflowers or bigger flowers", "child", "himself and the other trees", "the size of other birds", "his own size", "human", "flowers and landmark", "a person", "his award")))

```

Then, the minimally cleaned responses are classified as matching the critical noun (= subordinate) vs. non-matching (i.e., basic-level, matchin N2, superordinate). 
```{r classify}
# classify 2379 responses 
d_modRef_main_responseCat <- d_modRef_valid %>% 
  mutate(response_cat = ifelse(
    tolower(response) %in% 
      c("building", "buildings", "flower", "flowers", "potted plants", "plants", "fish",
        "fishes", "dog", "dogs", "tree", "trees", "bird", "birds",  
        "flowers in the distance", "other flowers", "the other flowers", "the other dogs",
        "big dogs", "birds in the distance", "flowers that are already sold", "flowers.",
        "the other buildings around it", "the dogs around it", "the buildings around it",
        "flowers around it", "dogs around it", "the other flowers around it", "other plants",
        "other trees", "other rescue dogs\nother rescue dogs", "other floers", 
        "fish in the tank", "flowers with red bows", "dogs with red bows", 
        "dogs with leashes", "birda", "breeds", "pets", "trees\ntrees", "dogs that are gifts",
        "rescued fish","dogs.", "fish.", "dogs with medals", "smaller dogs", "dogs with bows", 
        "building with landmarks", "guide dogs", "landmark buildings", "other birds", 
        "flowers along the path", "flowers in the pots", "gift flowers", "dogd", 
        "the other prize winner dogs", "the other smaller birds", "birds you have seen",
        "smaller trees like the bonsai", "dogs that you have seen so far", "trees in general",
        "the other plants they are seeing", "the other trees you have seen", "fish\nfish",
        "the other flowers at the shop", "trees other than the other red wood", 
        "the other trees", "training dogs", "contestants", "gods", "small dogs",
        "landmark flowers", "other buildings", "dogs in the contest", "the other service dogs",
        "the other rescue birds", "the smaller dogs", "the smaller flowers", 
        "birds in the group", "fowers", "other landmarked flowers.", "other fish",
        "flowers at the garden store","flowers in the group", "present", "winner", 
        "rescued dogs", 
        
        "landmark", "landmarks", "service-animal", "service-animals", "service animals",
        "rescue", "rescues", "prize-winner", "prize-winners", "prize winner", "prizewinners",
        "prize winners", "dog gifts", "land mark trees", "smaller service animals",
        "prize-winner dogs", "rescue fish", "prize winning dogs", "prize-winning dogs",
        "other prize-winner dogs", "otherprize winning dog", "landmark trees", 
        "flower gifts", "the other prize winner", "the other service animal", "show winner",
        "prize dogs", "rescue birds", "service dogs", "gift", "gifts", "gifts.", "prize dog",
        "big trees with a landmark", "prize-winners."), 
    "nonmatch", "match"
  ),
  response_num = ifelse(response_cat == "nonmatch", 1, 0)
  )

```

We also consider a more fine-grained 3-way response classification: basic-level responses (also containing superordinate responses), N2 responses (e.g., "prize-winners"), subordinate responses. 
```{r classify3way}
# detailed analysis of non-matching responses, distinguishing between basic, N2 and 
# subordinate comparison classes
d_modRef_main_responseCat_3way <- d_modRef_main_responseCat %>%
  mutate(
    response_cat = ifelse(
      tolower(response) %in% 
        c("building", "buildings", "flower", "flowers", "potted plants", "plants", "fish",
        "fishes", "dog", "dogs", "tree", "trees", "bird", "birds", "other dogs", 
        "flowers in the distance", "other flowers", "the other flowers", "the other dogs",
        "big dogs", "birds in the distance", "flowers that are already sold", "flowers.",
        "the other buildings around it", "the dogs around it", "the buildings around it",
        "flowers around it", "dogs around it", "the other flowers around it", "other plants",
        "other trees", "other rescue dogs\nother rescue dogs", "other floers", 
        "fish in the tank", "flowers with red bows", "dogs with red bows", 
        "dogs with leashes", "birda", "breeds", "pets", "trees\ntrees", "dogs that are gifts",
        "rescued fish","dogs.", "fish.", "dogs with medals", "smaller dogs", "dogs with bows", 
        "building with landmarks", "guide dogs", "landmark buildings", "other birds", 
        "flowers along the path", "flowers in the pots", "gift flowers", "dogd", 
        "the other prize winner dogs", "the other smaller birds", "birds you have seen",
        "smaller trees like the bonsai", "dogs that you have seen so far", "trees in general",
        "the other plants they are seeing", "the other trees you have seen", "fish\nfish",
        "the other flowers at the shop", "trees other than the other red wood", 
        "the other trees", "training dogs",  "gods", "small dogs",
        "landmark flowers", "other buildings", "dogs in the contest", "the other service dogs",
        "the other rescue birds", "the smaller dogs", "the smaller flowers", 
        "birds in the group", "fowers", "other landmarked flowers.", "other fish",
        "flowers at the garden store","flowers in the group", "prize-winner dogs",
        "rescued dogs", "rescue fish", "prize winning dogs", "prize-winning dogs",
        "other prize-winner dogs", "otherprize winning dog", "landmark trees",
        "prize dogs", "rescue birds", "service dogs", "prize dog", "big trees with a landmark"
        ), "basic",
      ifelse( tolower(response) %in% c("landmark", "landmarks", "service-animal", "service-animals",
                                       "service animals", "rescue", "rescues", "prize-winner",
                                       "prize-winners", "prize winner", "prizewinners",
        "prize winners", "dog gifts", "land mark trees", "smaller service animals",
        "flower gifts", "the other prize winner", "the other service animal", "show winner",
         "gift", "gifts", "gifts.", "prize-winners.", "present", "winner", "contestants"
                                       ), "N2", "subordinate")
    )
  )
```

##### Plots

Here the proportion of non-matching responses by-syntax and by-trial type is plotted. Error bars represent bootstrapped 95%-CIs. 

We see a small effect in the critical condition, and we see a pronounced effect in the filler conditions (replicating crucial results from CogSci Exp. 3).
```{r plot, echo=FALSE}
bar.width = 0.8
d_modRef_main_responseCat %>%  
  group_by(syntax, trial_type) %>%
  tidyboot_mean(column = response_num) -> d_modRef_main_responseCat.bs

d_modRef_main_responseCat.bs %>%
  ungroup() %>%
  mutate(syntax = factor(syntax, levels = c("subj", "pred"), 
                         labels = c("Subject NP", "Predicate NP"))) %>%
  ggplot(., aes(x=syntax, y = mean, ymin = ci_lower, ymax = ci_upper, fill=syntax)) +
  geom_col(position = position_dodge(bar.width), width = bar.width,
           alpha = 0.5, color="black", size = 0.5) +
  geom_linerange(position = position_dodge(bar.width), size = 0.5) +
  scale_y_continuous(limits = c(0, 1),
                     breaks = c(0, 0.5, 1))+
  ylab("Proportion of non-matching responses") +
  #theme_bw() +
  facet_grid(~trial_type)+
  ggtitle("Proportion of non-matching responses")
```

Here, counts of the three response categories (basic, N2, subordinate) in the critical direct-modification trials are plotted by-syntax. 
```{r plot2, echo = F}
# more fine-grained comparison class types within critical trials
d_modRef_main_responseCat_3way %>%
  filter(trial_type == "critical") %>%
  ggplot(., aes(x = response_cat, fill = response_cat)) +
  geom_bar(alpha = 0.8) +
  facet_grid(~syntax) +
  ggtitle("Response category counts in critical trials")
```

#### More possible exclusions 
Yet since the responses are quite noisy, we might consider excluding further responses. The paraphrase template is "It is {big, small} relative to other ___". Therefore, responses starting with "to the..." or "to other..." etc are technically ungrammatical. So the following preprocessing excludes the aforementioned responses additionally to the exclusions made before.
This excludes 77 responses in total (3.2%).

If we are being really strict, responses starting with "the.." could also be excluded (tbd).

```{r invalid2}
# apply more strict exclusion criteria

d_modRef_valid_strict <- d_modRef_main %>%
  subset(., !(tolower(response) %in% c(
"deandal", "compared to the other fish", "compared to the fish", "the size of the flower",
"pigeon or other common birds", "a rose", "pigeon", "trees or himself", "dogs or the bow",
"landmark or trees", "bow/gift", "sunflowers or bigger flowers", "child", 
"himself and the other trees", "the size of other birds", "his own size", "human", 
"flowers and landmark", "a person", "his award", "other flowers", "the other flowers", 
"the other dogs", "the other buildings around it", "the other flowers around it", "other plants",
"other trees", "other rescue dogs\nother rescue dogs", "other floers", "other birds",
"the other prize winner dogs", "the other smaller birds", "the other plants they are seeing",
"the other trees you have seen", "the other flowers at the shop", "the other trees",
"other buildings", "the other service dogs", "the other rescue birds", 
"other landmarked flowers.", "other fish", "other prize-winner dogs", "otherprize winning dog",
"the other prize winner", "the other service animal",
# also some subordinate responses start with "other"
"other doberman", "other bonsai trees", "other eagles", "other hummingbirds", 
"other sunflowers", "other clownfish rescues", "the other dandelion", "the other chihuahua", 
"the other doberman", "other dandelions"
  )))
```

Furthermore, there are some responses where the classification might not be clear. 

For instance, some responses refer to perceptual categories. as e.g., "birds you have seen". Since the perceptual context presents the basic-level category, so far such responses are classified as basic-level. There are modified basic-level responses ("smaller dogs", "the other smaller birds", "smaller trees like the bonsai", "small dogs", "the smaller dogs", "the smaller flowers", "smaller service animals",) or responses with a PP which are semantically very similar to the N2 ("flowers that are already sold","flowers with red bows", "dogs with red bows", "dogs with leashes", "dogs that are gifts", "dogs with medals", "dogs with bows", "building with landmarks", "big trees with a landmark").

There are also compound responses just difficult to classify, some of them containing both a subordinate noun and a basic-level noun or N2 ("trees other than the other red wood", "to the doberman service-animal", "prize winning pugs", "other bonsai trees", "tuna fish", "bonsai trees", "the prize-winner pug", "other clownfish rescues", "hummingbirds that have been rescued", "great dane dogs", "redwood trees"). So far, all these responses containing a subordinate N are classified as subordinate (= matching).   

These responses are classified in non-matching vs matching:
```{r classify-strict}
d_modRef_main_responseCat_strict <- d_modRef_valid_strict %>% 
  mutate(response_cat = ifelse(
    tolower(response) %in% 
      c("building", "buildings", "flower", "flowers", "potted plants", "plants", "fish",
        "fishes", "dog", "dogs", "tree", "trees", "bird", "birds",  
        "flowers in the distance", 
        "big dogs", "birds in the distance", "flowers that are already sold", "flowers.",
        "the dogs around it", "the buildings around it",
        "flowers around it", "dogs around it",  
        "fish in the tank", "flowers with red bows", "dogs with red bows", 
        "dogs with leashes", "birda", "breeds", "pets", "trees\ntrees", "dogs that are gifts",
        "rescued fish","dogs.", "fish.", "dogs with medals", "smaller dogs", "dogs with bows", 
        "building with landmarks", "guide dogs", "landmark buildings", 
        "flowers along the path", "flowers in the pots", "gift flowers", "dogd", 
        "birds you have seen",
        "smaller trees like the bonsai", "dogs that you have seen so far", "trees in general",
        "fish\nfish", "trees other than the other red wood", 
        "training dogs", "contestants", "gods", "small dogs",
        "landmark flowers", "dogs in the contest", "the smaller dogs", "the smaller flowers", 
        "birds in the group", "fowers", "flowers at the garden store","flowers in the group",
        "present", "winner", "rescued dogs", 
        
        "landmark", "landmarks", "service-animal", "service-animals", "service animals",
        "rescue", "rescues", "prize-winner", "prize-winners", "prize winner", "prizewinners",
        "prize winners", "dog gifts", "land mark trees", "smaller service animals",
        "prize-winner dogs", "rescue fish", "prize winning dogs", "prize-winning dogs",
        "landmark trees", "flower gifts", "show winner",
        "prize dogs", "rescue birds", "service dogs", "gift", "gifts", "gifts.", "prize dog",
        "big trees with a landmark", "prize-winners."), 
    "nonmatch", "match"
  ),
  response_num = ifelse(response_cat == "nonmatch", 1, 0)
  )

```

3-way classification of strictly preproccesed responses:
```{r classify3way-strict}
d_modRef_main_responseCat_strict_3way <- d_modRef_main_responseCat_strict %>%
  mutate(
    response_cat = ifelse(
      tolower(response) %in% 
        c("building", "buildings", "flower", "flowers", "potted plants", "plants", "fish",
        "fishes", "dog", "dogs", "tree", "trees", "bird", "birds", "other dogs", 
        "flowers in the distance", "other flowers", "the other flowers", "the other dogs",
        "big dogs", "birds in the distance", "flowers that are already sold", "flowers.",
        "the other buildings around it", "the dogs around it", "the buildings around it",
        "flowers around it", "dogs around it",  
        "fish in the tank", "flowers with red bows", "dogs with red bows", 
        "dogs with leashes", "birda", "breeds", "pets", "trees\ntrees", "dogs that are gifts",
        "rescued fish","dogs.", "fish.", "dogs with medals", "smaller dogs", "dogs with bows", 
        "building with landmarks", "guide dogs", "landmark buildings", 
        "flowers along the path", "flowers in the pots", "gift flowers", "dogd", 
        "birds you have seen",
        "smaller trees like the bonsai", "dogs that you have seen so far", "trees in general",
        "fish\nfish", "trees other than the other red wood", 
        "training dogs",  "gods", "small dogs",
        "landmark flowers",  "dogs in the contest", 
         "the smaller dogs", "the smaller flowers", 
        "birds in the group", "fowers", 
        "flowers at the garden store","flowers in the group", "prize-winner dogs",
        "rescued dogs", "rescue fish", "prize winning dogs", "prize-winning dogs",
         "landmark trees",
        "prize dogs", "rescue birds", "service dogs", "prize dog", "big trees with a landmark"
        ), "basic",
      ifelse( tolower(response) %in% c("landmark", "landmarks", "service-animal", "service-animals",
                                       "service animals", "rescue", "rescues", "prize-winner",
                                       "prize-winners", "prize winner", "prizewinners",
        "prize winners", "dog gifts", "land mark trees", "smaller service animals",
        "flower gifts", "show winner",
         "gift", "gifts", "gifts.", "prize-winners.", "present", "winner", "contestants"
                                       ), "N2", "subordinate")
    )
  )

```

##### Plots

The proportion of non-matching responses in the strictly preprocessed data is plotted by-syntax and by-trial type. No qualitative differences appear under the more strict preprocessing. 
```{r plot-strict, echo=FALSE}
bar.width = 0.8
d_modRef_main_responseCat_strict %>%  
  group_by(syntax, trial_type) %>%
  tidyboot_mean(column = response_num) -> d_modRef_main_responseCat.strict.bs

d_modRef_main_responseCat.strict.bs %>%
  ungroup() %>%
  mutate(syntax = factor(syntax, levels = c("subj", "pred"), 
                         labels = c("Subject NP", "Predicate NP"))) %>%
  ggplot(., aes(x=syntax, y = mean, ymin = ci_lower, ymax = ci_upper, fill=syntax)) +
  geom_col(position = position_dodge(bar.width), width = bar.width,
           alpha = 0.5, color="black", size = 0.5) +
  geom_linerange(position = position_dodge(bar.width), size = 0.5) +
  scale_y_continuous(limits = c(0, 1),
                     breaks = c(0, 0.5, 1))+
  ylab("Proportion of non-matching responses") +
  #theme_bw() +
  facet_grid(~trial_type)+
  ggtitle("Proportion of non-matching responses")
```

3-way response category counts in the strictly preprocessed data:
```{r plot2-strict, echo = F}
# more fine-grained comparison class types within critical trials
d_modRef_main_responseCat_strict_3way %>%
  filter(trial_type == "critical") %>%
  ggplot(., aes(x = response_cat, fill = response_cat)) +
  geom_bar(alpha = 0.8) +
  facet_grid(~syntax) +
  ggtitle("Response category counts in critical trials")
```

## Stats

In the following, the dataset where less strict exclusions were applied is used for analysis. 
The predictors are deviation-coded. 
```{r stats, warning=F, message=F, echo=F}
d_modRef_main_responseCat %>% 
  mutate(syntax_dev = factor(syntax, levels = c("subj", "pred")),
         trial_type_dev = factor(trial_type, levels = c( "filler", "critical"))) -> d_modRef_main_responseCat

contrasts(d_modRef_main_responseCat$syntax_dev) <- contr.sum(2)
contrasts(d_modRef_main_responseCat$trial_type_dev) <- contr.sum(2)

# same for 3-way classified data
d_modRef_main_responseCat_3way %>% 
  mutate(syntax_dev = factor(syntax, levels = c("subj", "pred")),
         trial_type_dev = factor(trial_type, levels = c( "filler", "critical"))) -> d_modRef_main_responseCat_3way

contrasts(d_modRef_main_responseCat_3way$syntax_dev) <- contr.sum(2)
contrasts(d_modRef_main_responseCat_3way$trial_type_dev) <- contr.sum(2)
```
First, the preregistered Bayesian logistic regression is run. Maximal RE structure is included:
```{r model, warning=FALSE, message=FALSE}
model <- brm(
  response_num ~ syntax_dev * trial_type_dev + (1 + syntax_dev * trial_type_dev | submission_id) + 
    (1 + syntax_dev * trial_type_dev | target),
  data = d_modRef_main_responseCat,
  family = "bernoulli",
  cores = 4,
  iter = 3000,
  chains = 4, 
  control = list(adapt_delta = 0.9)
) 
```

```{r}
summary(model)
```

The contrast of interest is the effect of syntax in the critical condition. 
``` {r contrasts}
# get effect of syntax by trial type 
model_draws <- model %>%
  spread_draws(b_Intercept, b_syntax_dev1, b_trial_type_dev1, `b_syntax_dev1:trial_type_dev1`) %>%
  mutate(critical_subj = b_Intercept + b_syntax_dev1 - b_trial_type_dev1 - `b_syntax_dev1:trial_type_dev1`,
         critical_pred = b_Intercept - b_syntax_dev1 - b_trial_type_dev1 + `b_syntax_dev1:trial_type_dev1`,
         syntax_critical = critical_subj - critical_pred, # subject vs predicate 
         filler_subj = b_Intercept + b_syntax_dev1 + b_trial_type_dev1 + `b_syntax_dev1:trial_type_dev1`,
         filler_pred = b_Intercept - b_syntax_dev1 + b_trial_type_dev1 - `b_syntax_dev1:trial_type_dev1`,
         syntax_filler = filler_subj - filler_pred) %>% # subject vs predicate
  select(b_Intercept, b_syntax_dev1, b_trial_type_dev1, `b_syntax_dev1:trial_type_dev1`, critical_subj, critical_pred, syntax_critical, filler_subj, filler_pred, syntax_filler) %>%
  gather(key, val) %>%
  group_by(key) %>%
  summarise(
    mean = mean(val),
    lower = quantile(val, probs = 0.025),
    upper = quantile(val, probs = 0.975)
  )
model_draws  
```

```{r, echo=F}
model %>%
  spread_draws(b_Intercept, b_syntax_dev1, b_trial_type_dev1, `b_syntax_dev1:trial_type_dev1`) %>%
  mutate(critical_subj = b_Intercept + b_syntax_dev1 - b_trial_type_dev1 - `b_syntax_dev1:trial_type_dev1`,
         critical_pred = b_Intercept - b_syntax_dev1 - b_trial_type_dev1 + `b_syntax_dev1:trial_type_dev1`,
         syntax_critical = critical_subj - critical_pred, # subject vs predicate 
         filler_subj = b_Intercept + b_syntax_dev1 + b_trial_type_dev1 + `b_syntax_dev1:trial_type_dev1`,
         filler_pred = b_Intercept - b_syntax_dev1 + b_trial_type_dev1 - `b_syntax_dev1:trial_type_dev1`,
         syntax_filler = filler_subj - filler_pred) %>% # subject vs predicate
  select(b_Intercept, b_syntax_dev1, b_trial_type_dev1, `b_syntax_dev1:trial_type_dev1`, critical_subj, critical_pred, syntax_critical, filler_subj, filler_pred, syntax_filler) %>%
  gather(key, val) -> posterior_samples
```
Compute the probability of the effect of syntax in the critical condition being credible:
```{r}
posterior_samples %>% filter(key == "syntax_critical") %>% summarize(prob = mean(val > 0))
```

Exploratory model on data without N2 responses
```{r warning=FALSE, message=FALSE}
d_modRef_main_responseCat_noN2 <- d_modRef_main_responseCat_3way %>% filter (response_cat != "N2")

logistic_model_noN2 <- brm(
  response_num ~ syntax_dev * trial_type_dev + (1 + syntax_dev * trial_type_dev | submission_id) + 
    (1 + syntax_dev * trial_type_dev | target),
  data = d_modRef_main_responseCat_noN2,
  family = "bernoulli",
  cores = 4,
  iter = 3000,
  chains = 4 #, 
#  control = list(adapt_delta = 0.9)
) 
summary(logistic_model_noN2)
```
```{r, echo=F}
logistic_model_noN2 %>%
  spread_draws(b_Intercept, b_syntax_dev1, b_trial_type_dev1, `b_syntax_dev1:trial_type_dev1`) %>%
  mutate(critical_subj = b_Intercept + b_syntax_dev1 - b_trial_type_dev1 - `b_syntax_dev1:trial_type_dev1`,
         critical_pred = b_Intercept - b_syntax_dev1 - b_trial_type_dev1 + `b_syntax_dev1:trial_type_dev1`,
         syntax_critical = critical_subj - critical_pred, # subject vs predicate 
         filler_subj = b_Intercept + b_syntax_dev1 + b_trial_type_dev1 + `b_syntax_dev1:trial_type_dev1`,
         filler_pred = b_Intercept - b_syntax_dev1 + b_trial_type_dev1 - `b_syntax_dev1:trial_type_dev1`,
         syntax_filler = filler_subj - filler_pred) %>% # subject vs predicate
  select(b_Intercept, b_syntax_dev1, b_trial_type_dev1, `b_syntax_dev1:trial_type_dev1`, critical_subj, critical_pred, syntax_critical, filler_subj, filler_pred, syntax_filler) %>%
  gather(key, val) %>%
  group_by(key) %>%
  summarise(
    mean = mean(val),
    lower = quantile(val, probs = 0.025),
    upper = quantile(val, probs = 0.975)
  ) -> posterior_samples_noN2
posterior_samples_noN2
```
Compute the probability of the effect of syntax in the critical condition being credible given the data without N2 responses:
```{r, echo=F}
logistic_model_noN2 %>%
  spread_draws(b_Intercept, b_syntax_dev1, b_trial_type_dev1, `b_syntax_dev1:trial_type_dev1`) %>%
  mutate(critical_subj = b_Intercept + b_syntax_dev1 - b_trial_type_dev1 - `b_syntax_dev1:trial_type_dev1`,
         critical_pred = b_Intercept - b_syntax_dev1 - b_trial_type_dev1 + `b_syntax_dev1:trial_type_dev1`,
         syntax_critical = critical_subj - critical_pred, # subject vs predicate 
         filler_subj = b_Intercept + b_syntax_dev1 + b_trial_type_dev1 + `b_syntax_dev1:trial_type_dev1`,
         filler_pred = b_Intercept - b_syntax_dev1 + b_trial_type_dev1 - `b_syntax_dev1:trial_type_dev1`,
         syntax_filler = filler_subj - filler_pred) %>% # subject vs predicate
  select(b_Intercept, b_syntax_dev1, b_trial_type_dev1, `b_syntax_dev1:trial_type_dev1`, critical_subj, critical_pred, syntax_critical, filler_subj, filler_pred, syntax_filler) %>%
  gather(key, val) %>%
 filter(key == "syntax_critical") %>% summarize(prob = mean(val > 0))
```

### Critical trials only

Fit the preregistered logistic model to critical trials only:
```{r, message=FALSE, warning=FALSE}
d_modRef_main_critical <- d_modRef_main_responseCat %>% filter(trial_type == "critical")

logistic_model_critical <- brm(
  response_num ~ syntax_dev + (1 + syntax_dev | submission_id) + 
    (1 + syntax_dev | target),
  data = d_modRef_main_critical,
  family = "bernoulli",
  cores = 4,
  iter = 3000,
  chains = 4 )

summary(logistic_model_critical)
```
Compute the probability of the effect of syntax being greater than 0:
```{r, echo=F}
logistic_model_critical %>%
  spread_draws(b_Intercept, b_syntax_dev1) %>%
  mutate(critical_subj = b_Intercept + b_syntax_dev1,
         critical_pred = b_Intercept - b_syntax_dev1,
         syntax_critical = critical_subj - critical_pred # subject vs predicate 
         ) %>% 
  select(b_Intercept, b_syntax_dev1, critical_subj, critical_pred, syntax_critical) %>%
  gather(key, val) %>%
 filter(key == "syntax_critical") %>% summarize(prob = mean(val > 0))
```

### Multinomial regression
We might run an exploratory multinomial regression in run on the 3-way classified responses on the whole dataset, but it takes quite long and not sure how much sense that makes.
```{r multinomial-model, warning=FALSE, message=F, eval=F}
# make the response category a factor
d_modRef_main_responseCat_3way <- d_modRef_main_responseCat_3way %>%
  mutate(response_cat = as.factor(response_cat))

model_multinomial <- brm(
  response_cat ~ syntax_dev * trial_type_dev + (1 + syntax_dev * trial_type_dev || submission_id) + 
    (1 + syntax_dev * trial_type_dev || target),
  data = d_modRef_main_responseCat_3way,
  family = "categorical",
  cores = 3,
  iter = 2000,
  chains = 3 #, 
  #control = list(adapt_delta = 0.9)
)

summary(model_multinomial)
```
For computational tractability reasons, the exploratory multinomial regression is run on critical trials only:
```{r warning=FALSE, message=F}
d_modRef_main_3way_critical <- d_modRef_main_responseCat_3way %>%
  mutate(syntax_dev = factor(syntax, levels = c("subj", "pred")),
         trial_type_dev = factor(trial_type, levels = c( "filler", "critical"))) %>%
  filter(trial_type == "critical")

contrasts(d_modRef_main_3way_critical$syntax_dev) <- contr.sum(2)

model_multinomial_critical <- brm(
  response_cat ~ syntax_dev + (1 + syntax_dev || submission_id) + 
    (1 + syntax_dev || target),
  data = d_modRef_main_3way_critical,
  family = "categorical",
  cores = 3,
  iter = 2000,
  chains = 3 
)
summary(model_multinomial_critical)
```

Extract contrasts of interest from the multinomial model on critical condition :
```{r}
# extract the probabilities of the different response types in different syntactic positions in the critical condition
# from Kruschke, Doing BDA

# not sure if the contrasts are right yet
posteriors_multinomial_critical <- model_multinomial_critical %>%
  spread_draws(b_muN2_Intercept, b_musubordinate_Intercept, b_muN2_syntax_dev1, b_musubordinate_syntax_dev1) %>%
  mutate(basic_subj = exp(0)/(exp(b_muN2_Intercept + b_muN2_syntax_dev1) + exp(b_musubordinate_Intercept + b_musubordinate_syntax_dev1) + exp(0)),
         basic_pred = exp(0) / (exp(b_muN2_Intercept - b_muN2_syntax_dev1) + exp(b_musubordinate_Intercept - b_musubordinate_syntax_dev1) + exp(0)),
         N2_subj = exp(b_muN2_Intercept + b_muN2_syntax_dev1) / (exp(b_muN2_Intercept + b_muN2_syntax_dev1) + exp(b_musubordinate_Intercept + b_musubordinate_syntax_dev1) + exp(0)),
         N2_pred = exp(b_muN2_Intercept - b_muN2_syntax_dev1) / (exp(b_muN2_Intercept - b_muN2_syntax_dev1) + exp(b_musubordinate_Intercept - b_musubordinate_syntax_dev1) + exp(0)),
         sub_subj = exp(b_musubordinate_Intercept + b_musubordinate_syntax_dev1) / (exp(b_muN2_Intercept + b_muN2_syntax_dev1) + exp(b_musubordinate_Intercept + b_musubordinate_syntax_dev1) + exp(0)),
         sub_pred = exp(b_musubordinate_Intercept - b_musubordinate_syntax_dev1) / (exp(b_muN2_Intercept - b_muN2_syntax_dev1) + exp(b_musubordinate_Intercept - b_musubordinate_syntax_dev1) + exp(0)),
         basic_syntax = basic_subj - basic_pred,
         N2_syntax = N2_subj - N2_pred,
         sub_syntax = sub_subj - sub_pred
                         ) %>%
  select(basic_subj, basic_pred, N2_subj, N2_pred, sub_subj, sub_pred, basic_syntax, N2_syntax, sub_syntax) %>%
  gather(key, val) %>%
  group_by(key) %>%
  summarise(
    mean = mean(val),
    lower = HDInterval::hdi(val, credMass = 0.95)[1],
    upper = HDInterval::hdi(val, credMass = 0.95)[2]
  )

posteriors_multinomial_critical
```

Compute likelihood of a credible effect of syntax for the subordinate response category:
```{r, echo=FALSE}
model_multinomial_critical %>%
  spread_draws(b_muN2_Intercept, b_musubordinate_Intercept, b_muN2_syntax_dev1, b_musubordinate_syntax_dev1) %>%
  mutate(basic_subj = exp(0)/(exp(b_muN2_Intercept + b_muN2_syntax_dev1) + exp(b_musubordinate_Intercept + b_musubordinate_syntax_dev1) + exp(0)),
         basic_pred = exp(0) / (exp(b_muN2_Intercept - b_muN2_syntax_dev1) + exp(b_musubordinate_Intercept - b_musubordinate_syntax_dev1) + exp(0)),
         N2_subj = exp(b_muN2_Intercept + b_muN2_syntax_dev1) / (exp(b_muN2_Intercept + b_muN2_syntax_dev1) + exp(b_musubordinate_Intercept + b_musubordinate_syntax_dev1) + exp(0)),
         N2_pred = exp(b_muN2_Intercept - b_muN2_syntax_dev1) / (exp(b_muN2_Intercept - b_muN2_syntax_dev1) + exp(b_musubordinate_Intercept - b_musubordinate_syntax_dev1) + exp(0)),
         sub_subj = exp(b_musubordinate_Intercept + b_musubordinate_syntax_dev1) / (exp(b_muN2_Intercept + b_muN2_syntax_dev1) + exp(b_musubordinate_Intercept + b_musubordinate_syntax_dev1) + exp(0)),
         sub_pred = exp(b_musubordinate_Intercept - b_musubordinate_syntax_dev1) / (exp(b_muN2_Intercept - b_muN2_syntax_dev1) + exp(b_musubordinate_Intercept - b_musubordinate_syntax_dev1) + exp(0)),
         basic_syntax = basic_subj - basic_pred,
         N2_syntax = N2_subj - N2_pred,
         sub_syntax = sub_subj - sub_pred
                         ) %>%
  select(basic_subj, basic_pred, N2_subj, N2_pred, sub_subj, sub_pred, basic_syntax, N2_syntax, sub_syntax) %>%
  gather(key, val) %>%
  filter(key == "sub_syntax") %>%
  summarize(prob = mean(val < 0))
```

## Detailed plots
Here the proportion of non-matching responses by-syntax in the critical condition is plotted by-item:
```{r plot-byItem, fig.height=15, fig.width=10}
d_modRef_main_responseCat %>%  
  group_by(syntax, trial_type, target) %>%
  tidyboot_mean(column = response_num) -> d_modRef_main_responseCat.targets

d_modRef_main_responseCat.targets %>%
  ungroup() %>%
  filter(trial_type == "critical") %>%
  mutate(syntax = factor(syntax, levels = c("subj", "pred"), 
                         labels = c("Subject NP", "Predicate NP"))) %>%
  ggplot(., aes(x=syntax, y = mean, ymin = ci_lower, ymax = ci_upper, fill=syntax)) +
  geom_col(position = position_dodge(bar.width), width = bar.width,
           alpha = 0.5, color="black", size = 0.5) +
  geom_linerange(position = position_dodge(bar.width), size = 0.5) +
  scale_y_continuous(limits = c(0, 1),
                     breaks = c(0, 0.5, 1))+
  ylab("Proportion of non-matching responses") +
  #theme_bw() +
  facet_wrap(~target, ncol=2) 
```

Here, the proportion of non-matching responses is plotted by-N2. The landmark items (buildings, trees and flowers) seem to be less sensitive to syntactic manipulations. 
```{r plot-byN2, fig.height=15, fig.width=6}

d_modRef_main_responseCat %>%  
  group_by(syntax, trial_type, ref_np) %>%
  tidyboot_mean(column = response_num) -> d_modRef_main_responseCat.N2

d_modRef_main_responseCat.N2 %>%
  ungroup() %>%
  filter(trial_type == "critical") %>%
  mutate(syntax = factor(syntax, levels = c("subj", "pred"), 
                         labels = c("Subject NP", "Predicate NP"))) %>%
  ggplot(., aes(x=syntax, y = mean, ymin = ci_lower, ymax = ci_upper, fill=syntax)) +
  geom_col(position = position_dodge(bar.width), width = bar.width,
           alpha = 0.5, color="black", size = 0.5) +
  geom_linerange(position = position_dodge(bar.width), size = 0.5) +
  scale_y_continuous(limits = c(0, 1),
                     breaks = c(0, 0.5, 1))+
  ylab("Proportion of non-matching responses") +
  #theme_bw() +
  facet_wrap(~ref_np, ncol = 1)
```

The counts of different response types by-N2 for checking if there are any inconsistencies:
```{r counts-byN2, fig.height=15, fig.width=6}
d_modRef_main_responseCat_3way %>%
  filter(trial_type == "critical") %>%
  ggplot(., aes(x = response_cat, fill = response_cat)) +
  geom_bar(alpha = 0.8) +
  facet_wrap(ref_np~syntax, ncol=2) 
```

## Exploratory descriptive stats
Look at the number of non-switchers (participants sticking to one type of response throughout): 
```{r}
# number of participants not switching between matching & non-matching responses 
d_modRef_main_responseCat %>% group_by(submission_id, response_cat) %>% count() %>% spread(response_cat, n) %>% filter((is.na(match) | is.na(nonmatch))) %>% nrow() 

# proportion of non-switching participants under two-way response classification
125/300

# number of participants not switching the response category under 3-way response categorization
d_modRef_main_responseCat_3way %>% group_by(submission_id, response_cat) %>% count() %>% 
  spread(response_cat, n) %>% mutate(basic = ifelse(is.na(basic), 0, basic),
                                     N2 = ifelse(is.na(N2), 0, N2),
                                     subordinate = ifelse(is.na(subordinate), 0, subordinate),
                                     sum = basic + N2 + subordinate) %>%
  filter((basic == sum) | (N2 == sum) | (subordinate == sum)) %>% nrow()

# proportion of non-switching participants under 3-way response classification 
76/300
```

Critical trials only:
```{r}
d_modRef_main_responseCat_3way %>% filter(trial_type == "critical") %>% 
  group_by(submission_id, response_cat) %>% count() %>% spread(response_cat, n) %>% 
  mutate(basic = ifelse(is.na(basic), 0, basic),
                                     N2 = ifelse(is.na(N2), 0, N2),
                                     subordinate = ifelse(is.na(subordinate), 0, subordinate),
                                     sum = basic + N2 + subordinate) %>%
  filter((basic == sum) | (N2 == sum) | (subordinate == sum)) %>% nrow()

113/300
```